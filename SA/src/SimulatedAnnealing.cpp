#include <bits/stdc++.h>
#include "iostream"
#include "fstream"
#include "string.h"
#include "stdlib.h"
#include "math.h"
#include "limits.h"
#include "time.h"
// User defined header file
#include "../include/SimulatedAnnealing.h"

using namespace std;
/******************************************************************************************************************
 * File           : SimulatedAnnealing.cpp
 *
 * Purpose        : Implementation of the travelling saleman problem using SA
 *
 * Author         : Hanumantappa Budihal
 * Date           : 30-09-2021
 *
 * Bugs Log       :
 *
 * Change Log     : Initial Creation : 30-09-2021
 *****************************************************************************************************************/

// TODO Need add the comments
/*****************************************************************************************************************
 * Purpose  :
 *
 * Inputs   :
 * Outputs  :
 * TODO     : Need to add the proper comments
 ******************************************************************************************************************/

/*****************************************************************************************************************
 * Function : GeneticAlgorithm (Constructor)
 *
 * Purpose  : Create the instane of GeneticAlgorithm with intial data *
 * Inputs   :  Data, size of population  and mutation rate
 ******************************************************************************************************************/

// End of Constructor

// TODO : Need add the usefull comments
TravellingSaleMan::TravellingSaleMan()
{
    temparature = 1000000000000000000;
    tStart = clock();
}

TravellingSaleMan::~TravellingSaleMan()
{
}

void TravellingSaleMan::SimulatedAnnealing()
{
    int r1, r2, i;
    double c1, c2, gain, randum_number, prob;
    readFile();
    init();

    while (1)
    {
        i = 100;
        while (--i)
        {
            for (int i = 1; i < n; i++)
                new_path[i] = curr_path[i];

            r1 = generateRandomNumber();
            r2 = generateRandomNumber();
            //  swap(r1, r2, new_path);
            two_opt(r1, r2, new_path);

            gain = getCost(new_path) - getCost(curr_path);
            randum_number = (double)(rand() / (double)RAND_MAX);

            prob = 1 / (1 + pow(M_E, (gain / temparature)));
            if (prob > randum_number)
                for (int i = 1; i < n; i++)
                    curr_path[i] = new_path[i];

            if (getCost(new_path) < getCost(min_path))
            {
                for (int i = 1; i < n; i++)
                    min_path[i] = new_path[i];
                retraceMinPath();
            }
        }
        temparature *= 0.999;
        //   cout<<temparature<<endl;
    }
}

void TravellingSaleMan::two_opt(int r1, int r2, int *new_path)
{
    int i, j, k, limit, temp;

    // for(i=0;i<n+1;i++) cout<<new_path[i]<<" ";cout<<"   :   ";

    if (r1 > r2)
    {
        temp = r1;
        r1 = r2;
        r2 = temp;
    }
    limit = floor((r2 - r1 + 1) / 2);
    i = r1, j = r2;

    for (k = 0; k < limit + 1; k++)
        swap(i++, j--, new_path);

    // for(i=0;i<n+1;i++) cout<<new_path[i]<<" ";cout<<endl;
}

void TravellingSaleMan::init()
{
    curr_path = new int[n + 1];
    curr_path[0] = curr_path[n] = 0;
    for (int i = 1; i < n; i++)
        curr_path[i] = i;

    new_path = new int[n + 1];
    new_path[0] = new_path[n] = 0;
    for (int i = 1; i < n; i++)
        new_path[i] = i;

    min_path = new int[n + 1];
    min_path[0] = min_path[n] = 0;
    for (int i = 1; i < n; i++)
        min_path[i] = i;
}

int TravellingSaleMan::getCost(int *path)
{
    int cost = 0;
    for (int i = 0; i < n; i++)
        cost += adjacency_matrix[path[i]][path[i + 1]];
    return cost;
}

void TravellingSaleMan::readFile()
{
    int i, j;

    cin >> distance_type;
    if (strcmp(distance_type, "non") == 0)
        cin >> distance_type;
    cin >> n;

    x = new double[n];
    y = new double[n];

    adjacency_matrix = new double *[n];
    for (i = 0; i < n; i++)
        adjacency_matrix[i] = new double[n];

    for (i = 0; i < n; i++)
    {
        cin >> x[i] >> y[i];
    }

    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            cin >> adjacency_matrix[i][j];
        }
    }
}

int TravellingSaleMan::generateRandomNumber()
{
    return (rand() % (n - 1)) + 1;
}

void TravellingSaleMan::swap(int r1, int r2, int *new_path)
{
    int temp = new_path[r1];
    new_path[r1] = new_path[r2];
    new_path[r2] = temp;
}

void TravellingSaleMan::retraceMinPath()
{
    printf("Time taken: %.2fs\n", (double)(clock() - tStart) / CLOCKS_PER_SEC);
    cout << "The shortest cost obtained so far is " << getCost(min_path) << endl;
    for (int i = 0; i < n; i++)
        cout << min_path[i] + 1 << " ";
    cout << endl;
}
